# 二分搜

對於一個函數 $F(n)$ ，如果存在一個 x，對於所有 $\\geq x$ 的 a， $F(a)=$ true，反之 $F(a)=$ false，基於這樣的單調性，就可以用二分搜。

```cpp
T binary_search() {
  while (L < R) {
    int M = (L + R) >> 1;
    if (F(M))
      R = M;
    else
      L = M + 1;
  }
  return L;
}
```

有些題目為 "最多/最少為何會成立"，那麼如果你可以在良好的時間檢查出 " 如果代價是 $x$ ，那可不可以達成目標 "，並且 $x$ 具有單調性，那麼你可以轉換成 " 如果代價是 $x$ ，那可不可以達成目標 " 傳換成 $F(x)$ ，對答案（x）進行二分搜。
二分搜要注意兩件事，一個是無限迴圈，要避免它可以在腦中先模擬一下。一個是在實數中二分搜，因為實數的稠密性，題目會有誤差容忍（例如 $10^{-6}$ )，只要在誤差內都是容許的。

## 三分搜

對於 U 型函數（例如 $y=F(x)=x^2$ )，我們想要找尋其極值，意謂其左右兩側皆各自遞增/遞減，我們可以利用三分搜來解決（二分搜只能解決全體單調性，不能解決有兩邊的）。
考慮三分後從左到右四個採樣點的關係

-  $S(a) < S(b) < S(c) < S(d)$ ，此時最小值一定不在最右邊
-  $S(a) > S(b) < S(c) < S(d)$ ，此時最小值一定不在最右邊
-  $S(a) > S(b) > S(c) < S(d)$ ，此時最小值一定不在最左邊
-    $S(a) > S(b) > S(c) > S(d)$ ，此時最小值一定不在最左邊
    這段描敘還可以再簡化
-  $S(b) < S(c)$ ，此時最小值一定不在最右邊
-    $S(b) > S(c)$ ，此時最小值一定不在最左邊
    每次都至少可以讓區間縮小 $\frac{1}{3}$ 

```cpp
double trinary_search(double l, double r) {
  static const double EPS = 1e−7;
  while (r−l > EPS) {
    double ml = (l + l + r) / 3, mr = (l + r + r) / 3;
    if (f(mr) > f(ml))
      r = mr;
    else
      l = ml;
  }
  return l;
}
```
