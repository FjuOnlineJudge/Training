# 枚舉（Enumerate)

枚舉是最直觀的演算法，列出所有可能的解，並判斷是否符合題目要求。容易寫出，但通常時間複雜度太大無法滿足題目時限。

通常在設計枚舉找出需要枚舉的參數，並選擇是要用迴圈或遞迴方式。如果評估時間複雜度的時候發現太大時，可搭配一些技巧來降低時間複雜度。

相對地，如果有些題目測資範圍小，時間複雜度大還是可以在時限內通過題目。

???+ "UVa 10167 - Birthday Cake"
    給定 $2N$ 個點，請找出一條線 $ax+by=0$，的兩端各有 $N$ 個點 $a,b\in[-500,500]$，且 $a,b$ 為整數。

$a,b$ 都只有，枚舉 $a,b$ 只有 $10^6$ 次方種可能，每次檢查 $2N(\le 100)$ 個點，約 $1000$ 種可能最多枚舉 $10^8$ 次，不會超過時限。

判斷 $(x,y)$ 在 $ax+by=0$ 的哪一側方法是將 $(x,y)$ 代入 $ax+by$ 中(這裡假設 $a,b$ 是固定的)。

- $ax+by=0$，在線上
- $ax+by<0$，在線的左側
- $ax+by>0$，在線的右側

## 特殊枚舉型態

### 集合

如果題目要求和集合有關係，可利用二進位表示一個集合，第 $i$ 位代表第 $i$ 樣物品選或不選 (0 或 1)。時間複雜度 $O(2^n)$ ，若執行時限為 $1$ 秒，枚舉大小最多約 $30$ 。

有遞迴和二進位兩種實現方式，前者較簡單。

```cpp
--8<-- "docs/algorithm/code/setEnumerate1.cpp"
```


```cpp
--8<-- "docs/algorithm/code/setEnumerate2.cpp"
```

???+ "AtCoder Regular Contest 061 A - Many Formulas"
    給定一個數字 $N\le 10^{11}$，可以在數字任意位置加上 `+` 成為算式，請輸出所有算式結果的和。
    範例：$125：125,1+25,12+5,1+2+5$

首先把整數轉成序列 ($125\to {1,2,5}$)，方便對每一位數操作。枚舉加號的放置位置，遞迴枚舉維護三個變數：位置、最後一個加號之前的和，最後一個加號之後的值。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/arc061A.cpp"
    ```


### 順序

如果題目要求和順序有關係，可利用 `<algorithm>` 內的 `next_permutation` 或 `prev_permutation` 達到枚舉元素的先後順序。時間複雜度為 $O(N!)$ ，若執行時限為 $1$ 秒，枚舉大小最多約 $10$ 。

下面題目用於練習如何枚舉順序：

???+ "UVa 10098 - Generating Fast"
    給定一個字串，一個字串有 $N!$ 種排序，請依據字典序大小輸出所有排序。

這題須利用到 `C++` `<algorithm>` 函式庫的 `sort` 和 `next_permutation` (可以參考[這個網站](https://hackingcpp.com/cpp/cheat_sheets.html#hfold0a))，前者用來求出第一小排序，後者找出下一個排序。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/uva10098.cpp"
    ```

## 技巧

### 減少枚舉維度

找出需要枚舉的參數後，有些參數可能是和結果無關，或是可由其他參數推導出，移除該參數可降低時間複雜度。

???+ Question "UVa10976 - Fractions Again?"
    給定 $k(0 < k \leq 100)$ ，請求出所有正整數解 $x,y(x \geq y)$ ，使得 $\frac{1}{k}=\frac{1}{x}+\frac{1}{y}$。

最直觀的解法是枚舉兩個參數 $x,y$ ，但其實只要知道 $x,y$ 任意一項就可推出另外一項，有根據題目我們可以得出 $y$ 在 $(k,2k]$ 之間（當 $x=y$ 時， $x=y=2k$ )，要枚舉的範圍較小，因此我們選擇枚舉 $y$ 的算法，時間複雜度為 $O(k)$ 

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/uva10976.cpp"
    ```

### 雙指標

利用兩個指標線性遍歷陣列，得出答案。「雙指標」可為兩個指標或是兩個整數型態變數紀錄位置。

???+ Question "UVa 11078 - Open Credit System"
    給定一個長度為 $N,(N \leq 150000)$ 的序列 $A$ ，求出一組 $i,j(i>j)$ 使得 $a_i-a_j$ 最大。

首先會直觀的想到一個 $O(N^2)$ 的算法：枚舉 $i,j$ 算出結果後取最大值。

接著可以想到對於每個數字 $a_i$ 只要和 $min(a_0,a_1,...,a_{i-1})$ 相減即可，設立一個變數 $min_j$，$a[min_j]=min(a_0,a_1,...,a_{i-1})$，答案 $ans$ 和 $a[i]-a[min_j]$ 取最大值，$i,min_j$ 更新 $N$ 次，時間複雜度 $O(N)$。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/doublePointer.cpp"
    ```

* * *

???+ Question "UVa11572 - Unique Snowflakes"
    給定一個長度為 $N,(N \leq 100000)$ 的序列 $A$ ，求出最長序列，當中沒有重複的數字

我們可以設兩個指標，左指標和右指標，每次迭代右指標先往前一個位置，如果左右指標之間有重複的數字，就將左指標往前一個位置，直到沒有左右指標之間沒有重複的數字。利用 `set` 來維護是否有重複數字，時間複雜度 $O(N\log N)$ 。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/uva11572.cpp"
    ```

### 折半枚舉

枚舉所有集合的時間複雜度太大，把元素拆成二份分別枚舉再合併，能夠降低時間複雜度，這種技巧稱為「折半枚舉」 (Meet in the Middle)。

???+ Question "AtCoder Beginner Contest 184 F - Programming Contest"
    給定 $N$ 個數字加起來，可以選任意多個數字，數字和不超過 $T$ 的情況上，最大數字和為多少?

數字分成兩個集合 $X,Y$，每一堆分別枚舉所有可能的數字和並排序，獲得 $Sx,Sy$。

- $1,3,5\to 0,1,3,4,5,6,8,9$
- $2,4,6\to 0,2,4,6,8,10,12$

枚舉集合 $Sx$ 的數字 $Sx_i$，找出 $Sy$ 集合內小於等於 $T-Sx_i$ 中最大的數 $Sy_j$。

- 更新答案 $ans=max(ans,Sx_i+Sy_j)$

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/abc184F.cpp"
    ```

???+ Question "UVa01326 - Jurassic Remains"
    給定 $N(N\leq 24)$ 串英文字串，請最多可以包含幾個字串，使得這些字串內每個字元都出現偶數次。

先把每個字串轉成一個二進位，第 $i$ 位表示字串有（0: 偶數，1: 奇數）個字元 i (0:A, 1:B, ...)。如果有一堆字串內每個字元都出現偶數次，那麼他們的 xor 值 $=0$ 。

這題關於「集合」，可用二進位枚舉，加上判斷，時間複雜度 $O(N\times 2^N)$ 。

使用拆半枚舉，把前 $\frac{N}{2}$ 和後 $\frac{N}{2}$ 字串分別枚舉，分別把結果存在不同的 map 裡面，如果兩個 map 有相同的 xor 值，代表兩個集合的字串合起來，每個字元都出現偶數次。這種做法時間複雜度為 $O(2^{\frac{n}{2}}\log 2^{\frac{n}{2}})$ 

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/uva01326.cpp"
    ```

???+ Question "UVa10125 - Sumsets"
    給定一個集合，請找到最大的 $d$ 滿足 $a+b+c=d$，$a,b,c,d$ 皆相異。

直接枚舉的複雜度式 $O(N^4)$，把式子移項成為 $a+b=d-c$，枚舉所有 $a+b$ 的結果，再枚舉 $d-c$，當枚舉出一組 $d-c$，就檢查是否有符合條件的 $a+b$。為了要判斷是否相異，要額外紀錄位置，題目要求最大的 $d$，因此由大往小枚舉 $d$。

枚舉 $a+b$ 和 $d-c$ 的時間複雜度 $O(N^2)$，檢查是否有符合條件的 $a+b$ 的時間複雜度 $O(\log N^2)$，整題時間複雜度 $O(N^2\log N^2)$。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/uva10125.cpp"
    ```

### 剪枝

在使用遞迴枚舉時，當搜尋到一組解答，發現該組解和其延伸的解，皆無法達到達到需求，就停止搜尋，改搜尋其他組解，該技巧叫做「剪枝」。

明確地來說，以下狀況需使用剪枝：

- 發現解答是不合法的。
- 在最佳化問題，發現無法成為最佳解。

剪枝能減少枚舉數量，降低執行時間。

???+ Qusetion
    給定一個數字 $N$ ，要你求出有幾組正整數解 $x_1,x_2,x_3,...,x_m$ ，使得 $x_1+x_2+x_3+...+x_m = N$ 。順序不同視為相同解，例如 $1+2$ 和 $2+1$ 視為相同組解。

- 為了避免算到重複組合，我們讓 $x_1 \leq x_2 \leq ...$ 。
- 設目前解總和為 $sum$ ，最後一項為 $max$ ，下一項 $i$ 就從 $max$ 開始嘗試，當嘗試到 $sum + i > N$ 時，就停止嘗試。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/prune.cpp"
    ```

???+ Qusetion "UVa 10364 - Square"
    給定 $N$ 根木棍的長度，在不折斷木棍的情況下，是否可以排出正方形?

- 如果長度和不是 $4$ 的倍數，或是最長長度大於長度和 $/4$，答案皆為否定。
- 木棍依長度從大到小排序，由長的棍子開始選能少回溯次數。
- 如果如果將上當前棍子後，累積長度大於邊長，跳過當前棍子改嘗試更短的棍子。
- 用一個 `bool` 陣列 $used$ 紀錄那些棍子是被用過的，避免棍子被重複枚舉。

??? "參考程式碼"

    ```cpp
    --8<-- "docs/algorithm/code/uva10364.cpp"
    ```

## 延伸閱讀

- [从枚举到 K 短路](https://zhuanlan.zhihu.com/p/56269536)

## 更多題目

- 折半枚舉：NCPC 2017 決賽 PF