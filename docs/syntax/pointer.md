# 指標 (Pointer)

## 傳址運算子與指標 (Pointer)

一個變數除了對應一種資料型態、一個值，還對應了一個位址（儲存該變數的記憶體位置）。

要知道一個變數的位置，可以用傳址運算子 `&` ，並附值給一個變數，存放位置的變數稱為「指標」。

指標宣告語法如下：

```cpp
type *ptr;
```

```cpp
int a = 5;
int *ptr = &a;
cout << ptr << '\n';
```

記憶體為動態配置，每次跑出的答案不盡相同。輸出為一個 16 進位的數字，開頭為 `0x` （代表 16 進位）。

指標不必在宣告階段設定初始值：

```cpp
int a = 5;
int *ptr;
ptr = &a;
```

指標可以宣告在同意一行，注意 `*` 要放在每個變數之前：

```cpp
int *a, b;  // 只有 a 是指標
int *a, b;  // 只有 a 是指標
int *a, *b; // a, b 都是指標
```

指標也是有維度的概念，一維指標存放任意非指標變數之位置，二維指標存放任意一維指標之位置。

```cpp
int a = 5;
int *ptr = &a;
int **ptr2 = &ptr;
cout << ptr << '\n';
```

## 間接運算子

我們可以對一個變數取其在記憶體的位置，反過來，也可以利用為間接運算子 `*` ，透過指標間接操作變數。

```cpp
int a = 5;
int *ptr = &a;
cout << (*ptr) << '\n';
\\ 5 cout << a << '\n';
\\ 5 ++(*ptr);
cout << (*ptr) << '\n';
\\ 6 cout << a << '\n';
\\ 6
```

上面範例程式碼都有出現 `*ptr` ，但意義不同，第一次出現是用來宣告 `ptr` 是（一維）指標，其餘是透過 `ptr` 指標操作 `a` 。

## 為何要用指標

- 動態配置記憶體：在執行程式時，記憶體是我們所需考量的點之一，任何變數可能會在任何時刻，成為不需要的資訊，成動態記憶體可在程式執行過程添加或刪除任何記憶體，減少記憶體資源。
- 複雜資料結構：陣列無法簡潔地表示各種圖、樹等非線性資料結構，在維護上會花費較多成本。

## 參考 (Reference)

參考型態代表一個變數的別名，可直接取得變數的位址，並間接透過參考型態別名來操作物件，作用類似於指標，但卻不必使用指標語法，也就是不必使 `*` 運算子來操作變數。

```cpp
int a = 5;
int &r = a;
++r;
cout << r << '\n';
```

指標對照版：

```cpp
int a = 5;
int *ptr = a;
++(*ptr);
cout << (*ptr) << '\n';
```

參考型態必須在宣告時設初始值。

```cpp
int &r; // error
```

參考型態可用在取代太長的變數（如： `a[x][y][z]` )。

## 函示傳入參數

函式傳入的參數，可以是一般、指標或是參考型態，以下以 Swap 來介紹：

### Call by value

傳入的變數為一般型態，會 "複製" 一份到函式，原本的變數不會有任何改變。

```cpp
void swap(int x, int y) {
  cout << x << ' ' << y << '\n'; // 1 2
  int t = x;
  x = y;
  y = t;
  cout << x << ' ' << y << '\n'; // 2 1
}
int main() {
  int a = 1, b = 2;
  cout << a << ' ' << b << '\n'; // 1 2
  swap(a, b);
  cout << a << ' ' << b << '\n'; // 1 2
}
```

### Call by address/value of pointer

傳入的變數為指標型態，函式內的變數改變，是對記憶體操作，所以原本的數字也會跟著改變。

```cpp
void swap(int *x, int *y) {
  cout << *x << ' ' << *y << '\n'; // 1 2
  int t = *x;
  *x = *y;
  *y = t;
  cout << *x << ' ' << *y << '\n'; // 2 1
}
int main() {
  int a = 1, b = 2;
  cout << a << ' ' << b << '\n'; // 1 2
  swap(&a, &b);
  cout << a << ' ' << b << '\n'; // 2 1
}
```

### Call by reference

傳入的變數為參考型態，函數內的變數是原本變數的分身，所以函數內變數改變時，原本變數也會跟者改變。

```cpp
void swap(int &x, int &y) {
  cout << x << ' ' << y << '\n'; // 1 2
  int t = x;
  x = y;
  y = t;
  cout << x << ' ' << y << '\n'; // 2 1
}
int main() {
  int a = 1, b = 2;
  cout << a << ' ' << b << '\n'; // 1 2
  swap(a, b);
  cout << a << ' ' << b << '\n'; // 2 1
}
```
